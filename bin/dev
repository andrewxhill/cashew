#!/bin/bash
# dev - Project session manager with git worktree support
#
# Structure supported:
#   ~/projects/<repo>/<worktree>/     - git worktrees
#   ~/projects/<repo>/                - regular repos
#
# Session naming uses "_" separator (internal session names don't allow "/"):
#   repo_worktree_sub  maps to  repo/worktree/sub in commands
#
# Usage:
#   dev                              - List all projects and sessions
#   dev <repo>                       - Attach to repo's main/default session
#   dev <repo>/<worktree>            - Attach to a specific worktree session
#   dev <repo>/<worktree>/<sub>      - Attach to sub-session (prefer /pi for worktrees)
#   dev hub                          - Attach to hub session at ~/projects root
#   dev hub/<sub>                    - Attach to hub sub-session (e.g., hub/claude)
#   dev new <repo> <url>             - Clone repo as bare + create main worktree
#   dev wt <repo> <branch> [base]    - Add a worktree for a branch
#   dev kill <session>               - Kill a specific session
#   dev kill-all                     - Kill all sessions

PROJECTS_DIR="$HOME/projects"  # Set by /setup skill during installation
if [ -d "$HOME/Projects" ]; then
    PROJECTS_DIR="$HOME/Projects"
fi
SEP="_"  # Session name separator (internal session names don't allow /)

# Colors
BOLD='\033[1m'
DIM='\033[2m'
CYAN='\033[36m'
GREEN='\033[32m'
YELLOW='\033[33m'
MAGENTA='\033[35m'
RED='\033[31m'
RESET='\033[0m'

# Convert path-style (repo/wt/sub) to session name (repo_wt_sub)
to_session_name() {
    echo "$1" | sed "s|/|${SEP}|g"
}

# Convert session name back to path-style for display
to_display_name() {
    echo "$1" | sed "s|${SEP}|/|g"
}

KW_META_DIR="$HOME/.pi/kw"

kw_safe() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's|[^a-z0-9._-]|-|g'
}

kw_meta_file() {
    local repo="$1"
    local name="$2"
    echo "$KW_META_DIR/$(kw_safe "$repo")__$(kw_safe "$name").json"
}

kw_meta_get() {
    local repo="$1"
    local name="$2"
    local field="$3"
    local file
    file=$(kw_meta_file "$repo" "$name")
    if [ ! -f "$file" ]; then
        echo ""
        return
    fi
    jq -r ".${field} // empty" "$file" 2>/dev/null
}

kw_tags_json() {
    local tags_csv="$1"
    local cleaned
    cleaned=$(echo "$tags_csv" | tr ',' '\n' | sed 's/^ *//;s/ *$//' | sed '/^$/d')
    if [ -z "$cleaned" ]; then
        echo "[]"
        return
    fi
    echo "$cleaned" | jq -R . | jq -s '.'
}

kw_write_meta() {
    local repo="$1"
    local name="$2"
    local tags_csv="$3"
    local description="$4"
    local session_dir="$5"
    local queue_file="$6"
    local status_file="$7"
    local session_path="$8"

    local file
    file=$(kw_meta_file "$repo" "$name")
    mkdir -p "$KW_META_DIR"

    local created_at
    local updated_at
    created_at=$(kw_meta_get "$repo" "$name" "createdAt")
    if [ -z "$created_at" ]; then
        created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    fi
    updated_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [ -z "$description" ]; then
        description=$(kw_meta_get "$repo" "$name" "description")
    fi
    if [ -z "$session_dir" ]; then
        session_dir=$(kw_meta_get "$repo" "$name" "sessionDir")
    fi
    if [ -z "$queue_file" ]; then
        queue_file=$(kw_meta_get "$repo" "$name" "queueFile")
    fi
    if [ -z "$status_file" ]; then
        status_file=$(kw_meta_get "$repo" "$name" "statusFile")
    fi
    if [ -z "$session_path" ]; then
        session_path=$(kw_meta_get "$repo" "$name" "sessionPath")
    fi

    local tags_json
    if [ -n "$tags_csv" ]; then
        tags_json=$(kw_tags_json "$tags_csv")
    else
        tags_json=$(jq -c '.tags // []' "$file" 2>/dev/null || echo "[]")
    fi

    jq -n \
        --arg repo "$repo" \
        --arg name "$name" \
        --arg description "$description" \
        --arg createdAt "$created_at" \
        --arg updatedAt "$updated_at" \
        --arg sessionDir "$session_dir" \
        --arg queueFile "$queue_file" \
        --arg statusFile "$status_file" \
        --arg sessionPath "$session_path" \
        --arg role "knowledge-worker" \
        --argjson tags "$tags_json" \
        '{repo: $repo, name: $name, role: $role, tags: $tags, description: $description, createdAt: $createdAt, updatedAt: $updatedAt, sessionDir: $sessionDir, queueFile: $queueFile, statusFile: $statusFile, sessionPath: $sessionPath}' \
        > "$file"
}

kw_queue_file() {
    local repo="$1"
    local name="$2"
    local safe_id
    safe_id="$(kw_safe "$repo")__$(kw_safe "$name")"
    echo "$HOME/.pi/queues/kw-${safe_id}.jsonl"
}

kw_status_file() {
    local repo="$1"
    local name="$2"
    local safe_id
    safe_id="$(kw_safe "$repo")__$(kw_safe "$name")"
    echo "$HOME/.pi/status/kw-${safe_id}.jsonl"
}

kw_session_dir() {
    local repo="$1"
    local name="$2"
    local safe_id
    safe_id="$(kw_safe "$repo")__$(kw_safe "$name")"
    echo "$HOME/.pi/agent/kw-sessions/kw-${safe_id}"
}

get_tmux_sessions() {
    if ! command -v tmux >/dev/null 2>&1; then
        return 0
    fi

    tmux list-sessions -F "#S" 2>/dev/null | grep -v "^$" || true
}

get_all_sessions() {
    get_tmux_sessions
}

session_backend() {
    local name="$1"

    if command -v tmux >/dev/null 2>&1; then
        if tmux has-session -t "$name" 2>/dev/null; then
            echo "tmux"
            return 0
        fi
    fi

    echo ""
    return 1
}

# Get Pi agent status indicator for a working directory.
# Returns a colored status tag or empty string if no Pi status exists.
pi_status_tag() {
    local cwd="$1"
    local safe_path
    safe_path=$(echo "$cwd" | tr '[:upper:]' '[:lower:]' | tr '/' '-' | sed 's/^-//')

    local status_file="$HOME/.pi/status/${safe_path}.jsonl"
    local queue_file="$HOME/.pi/queues/${safe_path}.jsonl"

    # No status file = no Pi info to show
    [ -f "$status_file" ] || return

    local last_line
    last_line=$(tail -n 1 "$status_file" 2>/dev/null)
    [ -z "$last_line" ] && return

    # Check if Pi's session file is newer than the status file (agent is mid-turn)
    local session_file
    session_file=$(echo "$last_line" | grep -oE '"sessionFile":"[^"]*"' | sed 's/"sessionFile":"//;s/"$//')
    if [ -n "$session_file" ] && [ -f "$session_file" ]; then
        local status_mtime session_mtime
        if [[ "$(uname)" == "Darwin" ]]; then
            status_mtime=$(stat -f "%m" "$status_file" 2>/dev/null)
            session_mtime=$(stat -f "%m" "$session_file" 2>/dev/null)
        else
            status_mtime=$(stat -c "%Y" "$status_file" 2>/dev/null)
            session_mtime=$(stat -c "%Y" "$session_file" 2>/dev/null)
        fi
        if [ -n "$session_mtime" ] && [ -n "$status_mtime" ] && [ "$session_mtime" -gt "$status_mtime" ]; then
            echo -e " ${GREEN}● working${RESET}"
            return
        fi
    fi

    # Working: agent_start fired, no agent_end yet (requires updated pi-subscribe extension)
    if echo "$last_line" | grep -q '"status":"working"'; then
        echo -e " ${GREEN}● working${RESET}"
        return
    fi

    # Queued: pending messages waiting to be processed
    if [ -f "$queue_file" ] && [ -s "$queue_file" ]; then
        echo -e " ${YELLOW}● queued${RESET}"
        return
    fi

    # Error: last turn had an error AND agent is not actively working
    if echo "$last_line" | grep -q '"errorMessage"' && ! echo "$last_line" | grep -qE '"errorMessage":\s*null'; then
        echo -e " ${RED}⚠ error${RESET}"
        return
    fi

    # Done/idle
    echo -e " ${CYAN}○ idle${RESET}"
}

list_active_sessions() {
    local sessions
    sessions=$(get_all_sessions)

    echo -e "${BOLD}Active sessions:${RESET}"
    if [ -n "$sessions" ]; then
        echo "$sessions" | while read -r line; do
            sess=$(echo "$line" | awk '{print $1}')
            display=$(to_display_name "$sess")
            local tag=""
            local pane_cwd
            pane_cwd=$(tmux display-message -p -t "$sess" '#{pane_current_path}' 2>/dev/null)
            [ -n "$pane_cwd" ] && tag=$(pi_status_tag "$pane_cwd")
            echo -e "  ${YELLOW}→${RESET} $display${tag} ${DIM}[$sess]${RESET}"
        done
    else
        echo -e "  ${DIM}(none)${RESET}"
    fi
}

list_projects() {
    local show_tree="${1:-0}"

    # Get all sessions
    sessions=$(get_all_sessions)

    if [ "$show_tree" -eq 1 ]; then
        echo -e "${BOLD}Projects in $PROJECTS_DIR:${RESET}"
        echo ""

        # Show hub session(s) first
        hub_sessions=$(echo "$sessions" | grep "^hub" || true)
        if [ -n "$hub_sessions" ]; then
            echo -e "  ${GREEN}●${RESET} ${BOLD}hub${RESET} ${DIM}($PROJECTS_DIR root)${RESET}"
            echo "$hub_sessions" | while read -r sess; do
                sess_name=$(echo "$sess" | awk '{print $1}')
                local tag
                tag=$(pi_status_tag "$PROJECTS_DIR")
                if [[ "$sess_name" == "hub" ]]; then
                    echo -e "      └─ main${tag} ${DIM}(dev hub)${RESET}"
                else
                    sub="${sess_name#hub${SEP}}"
                    echo -e "      └─ ${sub}${tag} ${DIM}(dev hub/$sub)${RESET}"
                fi
            done
        else
            echo -e "  ${DIM}○${RESET} hub ${DIM}(dev hub to start)${RESET}"
        fi
        echo ""

        for dir in "$PROJECTS_DIR"/*/; do
            [ -d "$dir" ] || continue
            project=$(basename "$dir")
            [[ "$project" == "dev" ]] && continue

            # Check if this is a worktree-based repo
            if [ -d "$dir/.bare" ]; then
                echo -e "  ${MAGENTA}◆${RESET} ${BOLD}$project${RESET} ${DIM}(worktrees)${RESET}"

                # List worktrees
                for wt_dir in "$dir"/*/; do
                    [ -d "$wt_dir" ] || continue
                    wt=$(basename "$wt_dir")
                    [[ "$wt" == ".bare" ]] && continue

                    # Check for sessions (using -- separator)
                    session_prefix="${project}${SEP}${wt}"
                    wt_sessions=$(echo "$sessions" | grep -E "^${session_prefix}($|${SEP})" || true)
                    if [ -n "$wt_sessions" ]; then
                        echo -e "      ${GREEN}●${RESET} ${CYAN}$wt${RESET}"
                        echo "$wt_sessions" | while read -r sess; do
                            sess_name=$(echo "$sess" | awk '{print $1}')
                            display=$(to_display_name "$sess_name")
                            local tag
                            tag=$(pi_status_tag "$wt_dir")
                            if [[ "$sess_name" == "$session_prefix" ]]; then
                                echo -e "          └─ main${tag} ${DIM}(dev $project/$wt)${RESET}"
                            else
                                sub="${sess_name#${session_prefix}${SEP}}"
                                echo -e "          └─ ${sub}${tag} ${DIM}(dev $project/$wt/$sub)${RESET}"
                            fi
                        done
                    else
                        echo -e "      ${DIM}○${RESET} ${DIM}$wt${RESET}"
                    fi
                done
            else
                # Regular repo
                session_prefix="${project}"
                project_sessions=$(echo "$sessions" | grep -E "^${session_prefix}($|${SEP})" || true)
                if [ -n "$project_sessions" ]; then
                    echo -e "  ${GREEN}●${RESET} ${BOLD}$project${RESET}"
                    echo "$project_sessions" | while read -r sess; do
                        sess_name=$(echo "$sess" | awk '{print $1}')
                        local tag
                        tag=$(pi_status_tag "$dir")
                        if [[ "$sess_name" == "$project" ]]; then
                            echo -e "      └─ main${tag} ${DIM}(dev $project)${RESET}"
                        else
                            sub="${sess_name#${project}${SEP}}"
                            echo -e "      └─ ${sub}${tag} ${DIM}(dev $project/$sub)${RESET}"
                        fi
                    done
                else
                    echo -e "  ${DIM}○${RESET} $project"
                fi
            fi
        done

        echo ""
    fi

    list_active_sessions

    echo ""
    echo -e "${DIM}Usage: dev hub | dev <repo>[/<worktree>][/<sub>] | dev new <repo> <url>${RESET}"
    if [ "$show_tree" -eq 0 ]; then
        echo -e "${DIM}Tip: dev ls --full to show full project tree${RESET}"
    fi
}

attach_session() {
    local input="$1"

    # Parse input: repo/worktree/sub or repo/sub or repo
    IFS='/' read -ra parts <<< "$input"

    local repo="${parts[0]}"
    local worktree=""
    local sub=""
    local session_name=""
    local target_dir=""

    local repo_dir="$PROJECTS_DIR/$repo"

    if [ ! -d "$repo_dir" ]; then
        echo "Project not found: $repo_dir"
        echo "Create it with: dev new $repo <git-url>"
        exit 1
    fi

    # Determine if worktree repo
    if [ -d "$repo_dir/.bare" ]; then
        # Worktree-based repo
        if [ ${#parts[@]} -ge 2 ]; then
            worktree="${parts[1]}"
            target_dir="$repo_dir/$worktree"

            if [ ! -d "$target_dir" ]; then
                echo "Worktree not found: $worktree"
                echo "Available worktrees:"
                for d in "$repo_dir"/*/; do
                    [ "$(basename "$d")" != ".bare" ] && echo "  - $(basename "$d")"
                done
                echo ""
                echo "Create with: dev wt $repo <branch>"
                exit 1
            fi

            session_name="${repo}${SEP}${worktree}"

            if [ ${#parts[@]} -ge 3 ]; then
                sub="${parts[2]}"
                session_name="${repo}${SEP}${worktree}${SEP}${sub}"
            fi
        else
            # Default to 'main' worktree if exists
            if [ -d "$repo_dir/main" ]; then
                worktree="main"
                target_dir="$repo_dir/main"
                session_name="${repo}${SEP}main"
            else
                # Pick first available worktree
                for d in "$repo_dir"/*/; do
                    if [ "$(basename "$d")" != ".bare" ]; then
                        worktree=$(basename "$d")
                        target_dir="$d"
                        session_name="${repo}${SEP}${worktree}"
                        break
                    fi
                done
            fi
        fi
    else
        # Regular repo
        target_dir="$repo_dir"
        session_name="$repo"

        if [ ${#parts[@]} -ge 2 ]; then
            sub="${parts[1]}"
            session_name="${repo}${SEP}${sub}"
        fi
    fi

    if [ -z "$target_dir" ] || [ ! -d "$target_dir" ]; then
        echo "Could not determine target directory"
        exit 1
    fi

    cd "$target_dir"
    local display_name=$(to_display_name "$session_name")
    echo -e "Directory: ${CYAN}$target_dir${RESET}"
    echo -e "Session: ${GREEN}$display_name${RESET}"

    local auto_command=()
    if [ -n "$sub" ]; then
        case "$sub" in
            pi)
                auto_command=(pi)
                ;;
            claude)
                auto_command=(claude --dangerously-skip-permissions)
                ;;
        esac
    else
        if [ -d "$repo_dir/.bare" ]; then
            auto_command=(pi)
        else
            auto_command=(claude --dangerously-skip-permissions)
        fi
    fi

    local backend
    backend=$(session_backend "$session_name")

    if [ "$backend" = "tmux" ]; then
        tmux attach -t "$session_name"
        return
    fi

    # If no sub specified on a worktree repo, check for existing pi sub-session
    if [ -z "$sub" ] && [ -d "$repo_dir/.bare" ]; then
        local pi_sub="${session_name}${SEP}pi"
        if [ "$(session_backend "$pi_sub")" = "tmux" ]; then
            echo -e "Attaching to existing pi sub-session: ${GREEN}$(to_display_name "$pi_sub")${RESET}"
            tmux attach -t "$pi_sub"
            return
        fi
    fi

    # Create new session detached (safe for non-interactive callers)
    tmux new-session -d -s "$session_name" -c "$target_dir"
    if [ ${#auto_command[@]} -gt 0 ]; then
        local cmd_line
        cmd_line="${auto_command[*]}"
        tmux send-keys -t "$session_name" "$cmd_line" C-m
    fi
    echo -e "${GREEN}Started:${RESET} $display_name (detached)"
    echo -e "Attach with: ${CYAN}dev $display_name${RESET}"
}

new_project() {
    local name="$1"
    local url="$2"
    local project_dir="$PROJECTS_DIR/$name"

    if [ -d "$project_dir" ]; then
        echo "Project already exists: $project_dir"
        exit 1
    fi

    if [ -z "$url" ]; then
        echo "Usage: dev new <project-name> <git-url>"
        exit 1
    fi

    echo "Setting up worktree-based repo..."
    mkdir -p "$project_dir"

    # Clone as bare repo
    echo "Cloning bare repo..."
    git clone --bare "$url" "$project_dir/.bare"

    # Configure the bare repo
    cd "$project_dir/.bare"
    git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git fetch origin

    # Create main worktree
    echo "Creating 'main' worktree..."
    cd "$project_dir"

    # Determine default branch
    default_branch=$(git --git-dir=.bare symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    git --git-dir=.bare worktree add main "$default_branch"

    echo ""
    echo -e "${GREEN}Project created!${RESET}"
    echo ""
    echo "Structure:"
    echo "  $PROJECTS_DIR/$name/"
    echo "  ├── .bare/     (git data)"
    echo "  └── main/      (default branch worktree)"
    echo ""
    echo "Commands:"
    echo "  dev $name/main/pi            # create or attach pi sub-session"
    echo "  dev $name/main/claude        # claude sub-session"
    echo "  dev wt $name feature-x       # add feature-x worktree (pi starts detached)"
}

add_worktree() {
    local repo="$1"
    local branch="$2"
    local base="${3:-main}"
    local repo_dir="$PROJECTS_DIR/$repo"

    if [ ! -d "$repo_dir/.bare" ]; then
        echo "Not a worktree-based repo: $repo"
        echo "Use 'dev new $repo <url>' to create one"
        exit 1
    fi

    if [ -z "$branch" ]; then
        echo "Usage: dev wt <repo> <branch> [base-branch]"
        exit 1
    fi

    cd "$repo_dir"

    # Fetch latest
    git --git-dir=.bare fetch origin

    # Check if branch exists remotely
    if git --git-dir=.bare show-ref --verify --quiet "refs/remotes/origin/$branch"; then
        echo "Creating worktree from existing remote branch: $branch"
        git --git-dir=.bare worktree add "$branch" "$branch"
    else
        echo "Creating new branch '$branch' from '$base'"
        git --git-dir=.bare worktree add -b "$branch" "$branch" "$base"
    fi

    local pi_session="${repo}${SEP}${branch}${SEP}pi"
    local started_pi=0
    if command -v tmux >/dev/null 2>&1 && command -v pi >/dev/null 2>&1; then
        if [ -z "$(session_backend "$pi_session")" ]; then
            tmux new-session -d -s "$pi_session" -c "$repo_dir/$branch"
            tmux send-keys -t "$pi_session" "pi" C-m
            started_pi=1
        fi
    fi

    echo ""
    echo -e "${GREEN}Worktree created!${RESET}"
    if [ "$started_pi" -eq 1 ]; then
        echo -e "  pi started in session: ${CYAN}dev $repo/$branch/pi${RESET} (detached)"
    fi
    echo "  dev $repo/$branch/pi         # attach to pi sub-session"
    echo "  dev $repo/$branch/claude     # claude sub-session"
}

kw_list() {
    local repo_filter="${1:-}"

    if [ ! -d "$KW_META_DIR" ]; then
        echo "No knowledge workers found."
        return
    fi

    local found=0
    for file in "$KW_META_DIR"/*.json; do
        [ -f "$file" ] || continue
        local repo
        local name
        local tags
        local description
        local updated
        local session_path
        repo=$(jq -r '.repo // ""' "$file" 2>/dev/null)
        if [ -n "$repo_filter" ] && [ "$repo_filter" != "$repo" ]; then
            continue
        fi
        name=$(jq -r '.name // ""' "$file" 2>/dev/null)
        tags=$(jq -r '.tags // [] | join(",")' "$file" 2>/dev/null)
        description=$(jq -r '.description // ""' "$file" 2>/dev/null)
        updated=$(jq -r '.updatedAt // ""' "$file" 2>/dev/null)
        session_path=$(jq -r '.sessionPath // empty' "$file" 2>/dev/null)

        if [ -z "$repo" ] || [ -z "$name" ]; then
            continue
        fi

        found=1
        if [ -n "$description" ]; then
            description=$(echo "$description" | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g')
        fi
        if [ -z "$session_path" ]; then
            session_path="${repo}/kw-${name}"
        fi
        echo "- ${session_path}  tags: ${tags:-none}  updated: ${updated:-unknown}"
        if [ -n "$description" ]; then
            echo "  note: $description"
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "No knowledge workers found."
    fi
}

kw_tag() {
    local input="$1"
    shift

    if [ -z "$input" ] || [ $# -eq 0 ]; then
        echo "Usage: dev kw-tags <repo>/<name> <tags>"
        echo ""
        echo "Set tags for a knowledge worker (comma-separated)."
        exit 1
    fi

    local tags_csv="$*"

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local name="${parts[1]:-}"
    if [ -z "$repo" ] || [ -z "$name" ]; then
        echo "Usage: dev kw-tags <repo>/<name> <tags>"
        exit 1
    fi

    kw_write_meta "$repo" "$name" "$tags_csv" "" "" "" "" ""
    echo "Updated tags for $repo/kw-$name"
}

kw_note() {
    local input="$1"
    shift

    if [ -z "$input" ] || [ $# -eq 0 ]; then
        echo "Usage: dev kw-note <repo>/<name> <note>"
        echo ""
        echo "Set description/note for a knowledge worker."
        exit 1
    fi

    local note="$*"

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local name="${parts[1]:-}"
    if [ -z "$repo" ] || [ -z "$name" ]; then
        echo "Usage: dev kw-note <repo>/<name> <note>"
        exit 1
    fi

    kw_write_meta "$repo" "$name" "" "$note" "" "" "" ""
    echo "Updated note for $repo/kw-$name"
}

kw_session() {
    local repo="$1"
    local name="$2"
    shift 2

    local tags=""
    local description=""
    local bootstrap=""
    local bootstrap_file=""
    local attach=0
    local worktree="main"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tags)
                tags="${2:-}"
                shift 2
                ;;
            --description|--desc)
                description="${2:-}"
                shift 2
                ;;
            --bootstrap|-b)
                bootstrap="${2:-}"
                shift 2
                ;;
            --bootstrap-file)
                bootstrap_file="${2:-}"
                shift 2
                ;;
            --worktree|-w)
                worktree="${2:-main}"
                shift 2
                ;;
            --attach|-a)
                attach=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ -z "$repo" ] || [ -z "$name" ]; then
        echo "Usage: dev kw <repo> <name> [--tags <tags>] [--description <text>] [--bootstrap <text>] [--bootstrap-file <file>] [--worktree <name>] [--attach]"
        exit 1
    fi

    local repo_dir="$PROJECTS_DIR/$repo"
    if [ ! -d "$repo_dir" ]; then
        echo "Repo not found: $repo"
        exit 1
    fi

    local target_dir=""
    local session_name=""
    local session_path=""

    if [ -d "$repo_dir/.bare" ]; then
        target_dir="$repo_dir/$worktree"
        if [ ! -d "$target_dir" ]; then
            echo "Worktree not found: $target_dir"
            exit 1
        fi
        session_name="${repo}${SEP}${worktree}${SEP}kw-${name}"
        session_path="$repo/$worktree/kw-${name}"
    else
        target_dir="$repo_dir"
        session_name="${repo}${SEP}kw-${name}"
        session_path="$repo/kw-${name}"
    fi

    local queue_file
    local status_file
    local session_dir
    queue_file=$(kw_queue_file "$repo" "$name")
    status_file=$(kw_status_file "$repo" "$name")
    session_dir=$(kw_session_dir "$repo" "$name")

    mkdir -p "$(dirname "$queue_file")" "$(dirname "$status_file")" "$session_dir"

    kw_write_meta "$repo" "$name" "$tags" "$description" "$session_dir" "$queue_file" "$status_file" "$session_path"

    if [ -z "$tags" ]; then
        tags=$(jq -r '.tags // [] | join(",")' "$(kw_meta_file "$repo" "$name")" 2>/dev/null)
    fi

    local backend
    backend=$(session_backend "$session_name")
    if [ "$backend" = "tmux" ]; then
        if [ "$attach" -eq 1 ]; then
            tmux attach -t "$session_name"
        else
            echo "Knowledge worker already running: $(to_display_name "$session_name")"
        fi
        return
    fi

    tmux new-session -d -s "$session_name" -c "$target_dir"

    local cmd_line
    local meta_file
    meta_file=$(kw_meta_file "$repo" "$name")
    printf -v cmd_line 'PI_ROLE=knowledge-worker PI_KW_ROLE=1 PI_KW_REPO=%q PI_KW_NAME=%q PI_KW_TAGS=%q PI_QUEUE_FILE=%q PI_STATUS_FILE=%q PI_KW_META_FILE=%q pi --session-dir %q' \
        "$repo" "$name" "$tags" "$queue_file" "$status_file" "$meta_file" "$session_dir"
    tmux send-keys -t "$session_name" "$cmd_line" C-m

    if [ -n "$bootstrap_file" ]; then
        if [ ! -f "$bootstrap_file" ]; then
            echo "Bootstrap file not found: $bootstrap_file"
        else
            bootstrap=$(cat "$bootstrap_file")
        fi
    fi

    if [ -z "$bootstrap" ]; then
        bootstrap=$'You are a knowledge-worker agent.\nFirst, familiarize yourself: read AGENTS.md and README.md, then skim docs/plans relevant to your domain and locate key packages/apps.\nSummarize your understanding and create a short guide for the PM (constraints, pitfalls, QA checks).\nRun /kw-tags tag1,tag2 and /kw-note inside your session (not in a response).'
    fi

    if [ -n "$bootstrap" ]; then
        send_pi "$session_path" "$bootstrap"
    fi

    echo -e "${GREEN}Knowledge worker started!${RESET}"
    echo -e "  session: ${CYAN}dev ${session_path}${RESET}"
    echo -e "  queue: ${DIM}${queue_file}${RESET}"
}

kill_session() {
    local input="$1"
    # Convert path-style to session name
    local session=$(to_session_name "$input")
    echo "Killing session: $session"

    local backend
    backend=$(session_backend "$session")

    if [ "$backend" = "tmux" ]; then
        tmux kill-session -t "$session"
        return
    fi

    echo "Session not found: $input"
    exit 1
}

cleanup_worktree() {
    local input="$1"
    shift

    local dry_run=0
    local force=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n)
                dry_run=1
                shift
                ;;
            --force|-f)
                force=1
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    if [ -z "$input" ]; then
        echo "Usage: dev cleanup <repo>/<worktree> [--dry-run] [--force]"
        echo ""
        echo "Kill the worktree session, remove the worktree, and delete the branch."
        echo "Refuses to delete branches with commits not in main unless --force is set."
        exit 1
    fi

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local worktree="${parts[1]:-}"
    if [ -z "$worktree" ]; then
        echo "Usage: dev cleanup <repo>/<worktree> [--dry-run] [--force]"
        exit 1
    fi

    local repo_dir="$PROJECTS_DIR/$repo"
    if [ ! -d "$repo_dir/.bare" ]; then
        echo "Not a worktree-based repo: $repo"
        exit 1
    fi

    local wt_dir="$repo_dir/$worktree"
    if [ ! -d "$wt_dir" ]; then
        echo "Worktree not found: $wt_dir"
        exit 1
    fi

    local session_name="${repo}${SEP}${worktree}"

    local ahead_count=0
    ahead_count=$(cd "$repo_dir" && git --git-dir=.bare rev-list --left-right --count "main...$worktree" 2>/dev/null | awk '{print $2}')
    ahead_count=${ahead_count:-0}

    if [ "$dry_run" -eq 1 ]; then
        echo "Would kill sessions matching: $session_name*"
        echo "Would remove worktree: $wt_dir"
        echo "Would delete branch: $worktree"
        if [ "$ahead_count" -gt 0 ]; then
            echo "Would delete $worktree with $ahead_count commits not in main (--force required)."
        fi
        return
    fi

    if [ "$ahead_count" -gt 0 ] && [ "$force" -ne 1 ]; then
        echo "Refusing to delete $worktree: $ahead_count commits not in main."
        echo "Use --force to delete anyway."
        exit 1
    fi

    # Kill base session and all sub-sessions (e.g., repo_wt_pi, repo_wt_claude)
    local sess
    for sess in $(get_all_sessions | grep -E "^${session_name}($|${SEP})"); do
        tmux kill-session -t "$sess" 2>/dev/null || true
    done

    (cd "$repo_dir" && git --git-dir=.bare worktree remove "$worktree")
    (cd "$repo_dir" && git --git-dir=.bare branch -D "$worktree")

    echo "Cleaned: $input"
}

kill_all_sessions() {
    echo "Killing all sessions..."
    tmux kill-server 2>/dev/null || true
}

send_keys() {
    local input="$1"
    shift

    if [ -z "$input" ] || [ $# -eq 0 ]; then
        echo "Usage: dev send <session> <keys...>"
        echo ""
        echo "Send raw keys to a tmux session (like tmux send-keys)."
        echo "Note: Enter/Return are sent as C-m."
        echo ""
        echo "Example:"
        echo "  dev send replay/arb-admin-sse 'pi' Enter"
        exit 1
    fi

    local session
    session=$(to_session_name "$input")

    local backend
    backend=$(session_backend "$session")

    if [ -z "$backend" ]; then
        echo "Session not found: $input"
        exit 1
    fi

    if [ "$backend" != "tmux" ]; then
        echo "Session backend not supported for send: $backend"
        exit 1
    fi

    local keys=()
    local key
    for key in "$@"; do
        case "$key" in
            Enter|enter|Return|RETURN)
                keys+=("C-m")
                ;;
            *)
                keys+=("$key")
                ;;
        esac
    done

    tmux send-keys -t "$session" "${keys[@]}"
}

send_pi() {
    local input="$1"
    shift
    local mode="followUp"
    local message=""
    local await_completion=0

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --steer|-s|--enter|-e)
                mode="steer"
                shift
                ;;
            --follow-up|-f|--queue|-q)
                mode="followUp"
                shift
                ;;
            --await|-w|--wait)
                await_completion=1
                shift
                ;;
            *)
                if [ -z "$message" ]; then
                    message="$1"
                else
                    message="$message $1"
                fi
                shift
                ;;
        esac
    done

    if [ -z "$input" ] || [ -z "$message" ]; then
        echo "Usage: dev send-pi <session> [--enter|--steer] <message>"
        echo ""
        echo "Send a message to a pi agent's queue."
        echo ""
        echo "Options:"
        echo "  --follow-up, -f  Queue for after agent finishes (default, like Alt+Enter)"
        echo "  --queue, -q      Alias for --follow-up"
        echo "  --steer, -s      Interrupt agent mid-run (like Enter)"
        echo "  --enter, -e      Alias for --steer"
        echo "  --await, -w      Wait for the next completion after sending"
        echo "  --wait           Alias for --await"
        echo ""
        echo "Examples:"
        echo "  dev send-pi replay/feature 'focus on the error handling next'"
        echo "  dev send-pi replay/main --enter 'stop and explain what you are doing'"
        echo "  dev send-pi replay/prod-fix --await 'review the plan and respond'"
        echo ""
        echo "Reminder: Always read the agent's last message before nudging."
        echo "  dev pi-status <session> --messages 1"
        echo "  dev queue-status <session> -m"
        echo "  dev requirements <session>"
        echo "Note: Requires the message-queue extension in ~/.pi/agent/extensions/"
        exit 1
    fi

    # Convert session path to directory path, then to queue file
    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local worktree="${parts[1]:-main}"
    local repo_dir="$PROJECTS_DIR/$repo"
    local target_dir=""
    local sub=""

    if [ -d "$repo_dir/.bare" ]; then
        target_dir="$repo_dir/$worktree"
        sub="${parts[2]:-}"
    else
        target_dir="$repo_dir"
        sub="${parts[1]:-}"
    fi

    if [ ! -d "$target_dir" ]; then
        echo "Directory not found: $target_dir"
        exit 1
    fi

    if [[ "$sub" == kw-* ]]; then
        local kw_name
        local queue_file
        kw_name="${sub#kw-}"
        queue_file=$(kw_meta_get "$repo" "$kw_name" "queueFile")
        if [ -z "$queue_file" ]; then
            queue_file=$(kw_queue_file "$repo" "$kw_name")
        fi
        mkdir -p "$(dirname "$queue_file")"

        local json_line
        json_line=$(jq -nc --arg message "$message" --arg mode "$mode" '{message: $message, mode: $mode}')
        if ! echo "$json_line" | jq -e . >/dev/null 2>&1; then
            echo "ERROR: message contains characters that break JSON encoding" >&2
            exit 1
        fi
        echo "$json_line" >> "$queue_file"

        local display_name
        display_name=$(to_display_name "$(to_session_name "$input")")
        echo -e "Queued for ${GREEN}${display_name}${RESET} (${mode}): $message"
        return
    fi

    if [ -n "$sub" ]; then
        local sub_dir="$target_dir/$sub"
        local dot_sub_dir="$target_dir/.${sub}"
        local chosen=""

        for candidate in "$sub_dir" "$dot_sub_dir"; do
            if [ -d "$candidate" ]; then
                local safe_candidate
                safe_candidate=$(echo "$candidate" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
                local session_candidate="$HOME/.pi/agent/sessions/--${safe_candidate}--"
                if [ -d "$session_candidate" ]; then
                    chosen="$candidate"
                    break
                fi
            fi
        done

        if [ -n "$chosen" ]; then
            target_dir="$chosen"
        fi
    fi

    # Convert path to queue file format (same as extension - lowercase)
    local safe_path
    safe_path=$(echo "$target_dir" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
    local queue_file="$HOME/.pi/queues/${safe_path}.jsonl"

    # Ensure queue directory exists
    mkdir -p "$HOME/.pi/queues"

    # Append message as JSONL (safe JSON encoding)
    local json_line
    json_line=$(jq -nc --arg message "$message" --arg mode "$mode" '{message: $message, mode: $mode}')
    if ! echo "$json_line" | jq -e . >/dev/null 2>&1; then
        echo "ERROR: message contains characters that break JSON encoding" >&2
        exit 1
    fi
    echo "$json_line" >> "$queue_file"

    local display_name
    display_name=$(to_display_name "$(to_session_name "$input")")
    echo -e "Queued for ${GREEN}${display_name}${RESET} (${mode}): $message"

    if [ "$await_completion" -eq 1 ]; then
        pi_subscribe "$input" --next
    fi
}

review_loop() {
    echo "Review loop (PM session):"
    echo "  1) List sessions: dev list"
    echo "  2) For each worktree agent:"
    echo "     - Read last message: dev pi-status <session> --messages 1"
    echo "     - Check requirements: dev requirements <session>"
    echo "     - If feedback requested, reply before reviewing"
    echo "  3) When agent says done: run code review skill"
    echo "  4) If review is clean: merge locally into main"
    echo "  5) Run: bash sleep 300 (in this session, foreground)"
    echo "  6) After sleep finishes, go back to step 1 and repeat"
    echo "  7) Do NOT write scripts, nohup, or background loops"
}

reboot_sessions() {
    local dry_run=0
    if [ "${1:-}" = "--dry-run" ]; then
        dry_run=1
        shift
    fi

    if ! command -v tmux >/dev/null 2>&1; then
        echo "tmux is required for dev reboot"
        exit 1
    fi

    echo -e "${BOLD}Rebooting sessions${RESET}"
    echo ""

    # Hub sessions
    if ! tmux has-session -t "hub${SEP}pi" 2>/dev/null; then
        if [ "$dry_run" -eq 1 ]; then
            echo "Would create: hub/pi"
        else
            tmux new-session -d -s "hub${SEP}pi" -c "$PROJECTS_DIR"
            tmux send-keys -t "hub${SEP}pi" "pi" C-m
            echo "Created: hub/pi"
        fi
    fi
    if ! tmux has-session -t "hub${SEP}claude" 2>/dev/null; then
        if [ "$dry_run" -eq 1 ]; then
            echo "Would create: hub/claude"
        else
            tmux new-session -d -s "hub${SEP}claude" -c "$PROJECTS_DIR"
            tmux send-keys -t "hub${SEP}claude" "claude --dangerously-skip-permissions" C-m
            echo "Created: hub/claude"
        fi
    fi

    for dir in "$PROJECTS_DIR"/*/; do
        [ -d "$dir" ] || continue
        local project
        project=$(basename "$dir")
        [[ "$project" == "dev" ]] && continue

        if [ -d "$dir/.bare" ]; then
            # Main worktree gets claude + pi sessions
            if [ -d "$dir/main" ]; then
                local main_claude
                local main_pi
                main_claude="${project}${SEP}main${SEP}claude"
                main_pi="${project}${SEP}main${SEP}pi"
                if ! tmux has-session -t "$main_claude" 2>/dev/null; then
                    if [ "$dry_run" -eq 1 ]; then
                        echo "Would create: $project/main/claude"
                    else
                        tmux new-session -d -s "$main_claude" -c "$dir/main"
                        tmux send-keys -t "$main_claude" "claude --dangerously-skip-permissions" C-m
                        echo "Created: $project/main/claude"
                    fi
                fi
                if ! tmux has-session -t "$main_pi" 2>/dev/null; then
                    if [ "$dry_run" -eq 1 ]; then
                        echo "Would create: $project/main/pi"
                    else
                        tmux new-session -d -s "$main_pi" -c "$dir/main"
                        tmux send-keys -t "$main_pi" "pi" C-m
                        echo "Created: $project/main/pi"
                    fi
                fi
            fi

            # Other worktrees: pi sessions
            for wt_dir in "$dir"/*/; do
                [ -d "$wt_dir" ] || continue
                local worktree
                worktree=$(basename "$wt_dir")
                [[ "$worktree" == ".bare" ]] && continue
                [[ "$worktree" == "main" ]] && continue

                local pi_session
                pi_session="${project}${SEP}${worktree}${SEP}pi"
                if tmux has-session -t "$pi_session" 2>/dev/null; then
                    continue
                fi

                if [ "$dry_run" -eq 1 ]; then
                    echo "Would create: $project/$worktree/pi"
                else
                    tmux new-session -d -s "$pi_session" -c "$wt_dir"
                    tmux send-keys -t "$pi_session" "pi" C-m
                    echo "Created: $project/$worktree/pi"
                fi
            done
        else
            # Regular repo: claude + pi sessions
            local repo_claude
            local repo_pi
            repo_claude="${project}${SEP}claude"
            repo_pi="${project}${SEP}pi"
            if ! tmux has-session -t "$repo_claude" 2>/dev/null; then
                if [ "$dry_run" -eq 1 ]; then
                    echo "Would create: $project/claude"
                else
                    tmux new-session -d -s "$repo_claude" -c "$dir"
                    tmux send-keys -t "$repo_claude" "claude --dangerously-skip-permissions" C-m
                    echo "Created: $project/claude"
                fi
            fi
            if ! tmux has-session -t "$repo_pi" 2>/dev/null; then
                if [ "$dry_run" -eq 1 ]; then
                    echo "Would create: $project/pi"
                else
                    tmux new-session -d -s "$repo_pi" -c "$dir"
                    tmux send-keys -t "$repo_pi" "pi" C-m
                    echo "Created: $project/pi"
                fi
            fi
        fi
    done
}

requirements() {
    local input="$1"
    shift

    local action="show"
    local append=0
    local clear=0
    local message=""

    if [ -z "$input" ]; then
        echo "Usage: dev requirements <session> [--append|--clear] [text]"
        echo ""
        echo "Store or view optional requirements/notes for an agent session."
        echo ""
        echo "Examples:"
        echo "  dev requirements replay/feature/pi \"Needs feedback on API shape\""
        echo "  dev requirements replay/feature/pi --append \"Confirm edge cases\""
        echo "  dev requirements replay/feature/pi"
        exit 1
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --append|-a)
                append=1
                shift
                ;;
            --clear|-c)
                clear=1
                shift
                ;;
            --show|-s)
                action="show"
                shift
                ;;
            *)
                if [ -z "$message" ]; then
                    message="$1"
                else
                    message="$message $1"
                fi
                shift
                ;;
        esac
    done

    local session
    session=$(to_session_name "$input")
    local req_dir="$HOME/.pi/requirements"
    local req_file="$req_dir/${session}.txt"

    mkdir -p "$req_dir"

    if [ "$clear" -eq 1 ]; then
        rm -f "$req_file"
        echo "Cleared requirements: $input"
        return
    fi

    if [ -n "$message" ]; then
        if [ "$append" -eq 1 ] && [ -f "$req_file" ]; then
            printf "%s\n" "$message" >> "$req_file"
        else
            printf "%s\n" "$message" > "$req_file"
        fi
    fi

    if [ ! -f "$req_file" ] || [ ! -s "$req_file" ]; then
        echo "(no requirements)"
        return
    fi

    echo "Requirements for $input:"
    cat "$req_file"
}

pi_status() {
    local input="$1"
    shift

    local messages_count=""
    local show_tools=0
    local show_errors=0
    local show_cost=0
    local follow=0
    local since=""
    local show_summary=1
    local view_flags=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --messages|-m)
                if [ -z "${2:-}" ]; then
                    echo "Missing value for --messages"
                    exit 1
                fi
                messages_count="$2"
                shift 2
                view_flags=1
                ;;
            --tools|-t)
                show_tools=1
                shift
                view_flags=1
                ;;
            --errors|-e)
                show_errors=1
                shift
                view_flags=1
                ;;
            --cost|-c)
                show_cost=1
                shift
                view_flags=1
                ;;
            --since)
                if [ -z "${2:-}" ]; then
                    echo "Missing value for --since"
                    exit 1
                fi
                since="$2"
                shift 2
                ;;
            --follow|-f)
                follow=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ -z "$input" ]; then
        echo "Usage: dev pi-status <session> [options]"
        echo ""
        echo "Show recent activity from a pi agent's session."
        echo ""
        echo "Options:"
        echo "  --messages, -m <n>  Show last n user/assistant messages"
        echo "  --tools, -t         Show recent tool calls"
        echo "  --errors, -e        Show errors/failures only"
        echo "  --cost, -c          Show token usage and cost totals"
        echo "  --since <window>    Limit to recent activity (e.g., 10m, 2h, 1d)"
        echo "  --follow, -f        Tail new activity (like tail -f)"
        exit 1
    fi

    if [ "$view_flags" -eq 1 ]; then
        show_summary=0
    fi

    local cutoff_ms=0
    if [ -n "$since" ]; then
        if [[ "$since" =~ ^([0-9]+)([smhd]?)$ ]]; then
            local amount="${BASH_REMATCH[1]}"
            local unit="${BASH_REMATCH[2]}"
            local seconds=0
            case "$unit" in
                ""|"s") seconds="$amount" ;;
                "m") seconds=$((amount * 60)) ;;
                "h") seconds=$((amount * 3600)) ;;
                "d") seconds=$((amount * 86400)) ;;
                *)
                    echo "Invalid --since value: $since (use Ns, Nm, Nh, Nd)"
                    exit 1
                    ;;
            esac
            local now_s
            now_s=$(date +%s)
            cutoff_ms=$(((now_s - seconds) * 1000))
        else
            echo "Invalid --since value: $since (use Ns, Nm, Nh, Nd)"
            exit 1
        fi
    fi

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local worktree="${parts[1]:-main}"
    local repo_dir="$PROJECTS_DIR/$repo"
    local target_dir=""
    local sub=""

    if [ -d "$repo_dir/.bare" ]; then
        target_dir="$repo_dir/$worktree"
        sub="${parts[2]:-}"
    else
        target_dir="$repo_dir"
        sub="${parts[1]:-}"
    fi

    if [ ! -d "$target_dir" ]; then
        echo "Directory not found: $target_dir"
        exit 1
    fi

    local session_dir=""
    if [[ "$sub" == kw-* ]]; then
        local kw_name
        kw_name="${sub#kw-}"
        session_dir=$(kw_meta_get "$repo" "$kw_name" "sessionDir")
        if [ -z "$session_dir" ]; then
            session_dir=$(kw_session_dir "$repo" "$kw_name")
        fi
    else
        local safe_path
        safe_path=$(echo "$target_dir" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
        session_dir="$HOME/.pi/agent/sessions/--${safe_path}--"

        if [ ! -d "$session_dir" ]; then
            safe_path=$(echo "$target_dir" | sed 's|/|-|g' | sed 's|^-||')
            session_dir="$HOME/.pi/agent/sessions/--${safe_path}--"
        fi
    fi

    if [ ! -d "$session_dir" ]; then
        echo "No pi sessions found for: $input"
        echo ""
        echo "Available sessions:"
        ls -1 "$HOME/.pi/agent/sessions/" 2>/dev/null | head -10
        exit 1
    fi

    local session_file
    session_file=$(ls "$session_dir"/*.jsonl 2>/dev/null | sort | tail -1)
    if [ -z "$session_file" ]; then
        echo "No session files found"
        exit 1
    fi

    format_time() {
        local ts_ms="$1"
        if [ -z "$ts_ms" ] || [ "$ts_ms" = "null" ]; then
            echo "unknown"
            return
        fi
        if ! [[ "$ts_ms" =~ ^[0-9]+$ ]]; then
            echo "unknown"
            return
        fi
        local ts_s=$((ts_ms / 1000))
        date -r "$ts_s" "+%Y-%m-%d %H:%M:%S"
    }

    echo -e "${BOLD}Session:${RESET} $input"
    echo -e "${DIM}File: $session_file${RESET}"
    if [ -n "$since" ]; then
        echo -e "${DIM}Window: last $since${RESET}"
    fi
    echo ""

    if [ "$show_summary" -eq 1 ]; then
        echo -e "${BOLD}Summary:${RESET}"
        local last_message_json
        last_message_json=$(jq -c --argjson cutoff "$cutoff_ms" 'select(.type=="message") | select((.message.timestamp // 0) >= $cutoff)' "$session_file" | tail -1)

        if [ -z "$last_message_json" ]; then
            echo "  No activity"
        else
            local last_role
            local last_ts_ms
            local last_text
            local last_status
            last_role=$(echo "$last_message_json" | jq -r '.message.role // "unknown"')
            last_ts_ms=$(echo "$last_message_json" | jq -r '.message.timestamp // empty')
            last_text=$(echo "$last_message_json" | jq -r '
                def text_of:
                  if (.message.content | type) == "string" then .message.content
                  else ([.message.content[]? | select(.type=="text") | .text] | join(" ")) end;
                text_of // ""')
            if [ -z "$last_text" ]; then
                last_text="(no text)"
            fi

            case "$last_role" in
                assistant)
                    local stop_reason
                    local error_msg
                    stop_reason=$(echo "$last_message_json" | jq -r '.message.stopReason // empty')
                    error_msg=$(echo "$last_message_json" | jq -r '.message.errorMessage // empty')
                    last_status="assistant"
                    if [ -n "$stop_reason" ]; then
                        last_status="assistant ($stop_reason)"
                    fi
                    if [ -n "$error_msg" ]; then
                        last_status="assistant error: $error_msg"
                    fi
                    ;;
                toolResult)
                    local tool_name
                    local is_error
                    tool_name=$(echo "$last_message_json" | jq -r '.message.toolName // "tool"')
                    is_error=$(echo "$last_message_json" | jq -r '.message.isError // false')
                    if [ "$is_error" = "true" ]; then
                        last_status="tool error: $tool_name"
                    else
                        last_status="tool result: $tool_name"
                    fi
                    ;;
                bashExecution)
                    local exit_code
                    local cancelled
                    exit_code=$(echo "$last_message_json" | jq -r '.message.exitCode // empty')
                    cancelled=$(echo "$last_message_json" | jq -r '.message.cancelled // false')
                    if [ "$cancelled" = "true" ]; then
                        last_status="bash cancelled"
                    elif [ -n "$exit_code" ]; then
                        last_status="bash exit $exit_code"
                    else
                        last_status="bash execution"
                    fi
                    ;;
                user)
                    last_status="user"
                    ;;
                *)
                    last_status="$last_role"
                    ;;
            esac

            echo "  Last message: [$(format_time "$last_ts_ms")] $last_role"
            echo "  Status: $last_status"
            echo "  Text: $last_text"

            local last_assistant_json
            last_assistant_json=$(jq -c --argjson cutoff "$cutoff_ms" 'select(.type=="message" and .message.role=="assistant") | select((.message.timestamp // 0) >= $cutoff)' "$session_file" | tail -1)
            if [ -n "$last_assistant_json" ]; then
                local total_tokens
                local input_tokens
                local output_tokens
                local cost_total
                total_tokens=$(echo "$last_assistant_json" | jq -r '.message.usage.totalTokens // 0')
                input_tokens=$(echo "$last_assistant_json" | jq -r '.message.usage.input // 0')
                output_tokens=$(echo "$last_assistant_json" | jq -r '.message.usage.output // 0')
                cost_total=$(echo "$last_assistant_json" | jq -r '.message.usage.cost.total // 0')
                printf "  Tokens: %s (in %s / out %s)\n" "$total_tokens" "$input_tokens" "$output_tokens"
                printf "  Cost: $%.4f\n" "$cost_total"
            fi
        fi
        echo ""
    fi

    if [ -n "$messages_count" ]; then
        echo -e "${BOLD}Messages (last $messages_count):${RESET}"
        local message_lines
        message_lines=$(jq -r --argjson cutoff "$cutoff_ms" '
            def text_of:
              if (.message.content | type) == "string" then .message.content
              else ([.message.content[]? | select(.type=="text") | .text] | join(" ")) end;
            def clean_text:
              gsub("[\\t\\r\\n]+"; " ");
            select(.type=="message")
            | select((.message.timestamp // 0) >= $cutoff)
            | select(.message.role=="user" or .message.role=="assistant")
            | (.message.timestamp|tostring) + "\t" + .message.role + "\t" + ((text_of // "") | clean_text)' "$session_file" | tail -n "$messages_count")

        if [ -z "$message_lines" ]; then
            echo "  (none)"
        else
            echo "$message_lines" | while IFS=$'\t' read -r ts role text; do
                if [ -z "$text" ]; then
                    text="(no text)"
                fi
                echo "  [$(format_time "$ts")] $role: $text"
            done
        fi
        echo ""
    fi

    if [ "$show_tools" -eq 1 ]; then
        echo -e "${BOLD}Tool calls:${RESET}"
        local tool_lines
        tool_lines=$(jq -r --argjson cutoff "$cutoff_ms" '
            select(.type=="message" and .message.role=="assistant")
            | select((.message.timestamp // 0) >= $cutoff)
            | . as $m
            | $m.message.content[]?
            | select(.type=="toolCall")
            | ($m.message.timestamp|tostring) + "\t" + .name' "$session_file" | tail -n 20)

        if [ -z "$tool_lines" ]; then
            echo "  (none)"
        else
            echo "$tool_lines" | while IFS=$'\t' read -r ts name; do
                echo "  [$(format_time "$ts")] $name"
            done
        fi
        echo ""
    fi

    if [ "$show_errors" -eq 1 ]; then
        echo -e "${BOLD}Errors:${RESET}"
        local error_lines
        error_lines=$(jq -r --argjson cutoff "$cutoff_ms" '
            select(.type=="message")
            | select((.message.timestamp // 0) >= $cutoff)
            | if .message.role=="toolResult" and (.message.isError==true) then
                (.message.timestamp|tostring) + "\ttoolResult\t" + (.message.toolName // "tool")
              elif .message.role=="assistant" and ((.message.stopReason=="error") or (.message.errorMessage // "") != "") then
                (.message.timestamp|tostring) + "\tassistant\t" + (.message.errorMessage // .message.stopReason // "error")
              elif .message.role=="bashExecution" and ((.message.cancelled==true) or ((.message.exitCode // 0) != 0)) then
                (.message.timestamp|tostring) + "\tbash\t" + (if .message.cancelled==true then "cancelled" else "exit " + ((.message.exitCode // 0)|tostring) end)
              else empty end' "$session_file" | tail -n 20)

        if [ -z "$error_lines" ]; then
            echo "  (none)"
        else
            echo "$error_lines" | while IFS=$'\t' read -r ts kind detail; do
                echo "  [$(format_time "$ts")] $kind: $detail"
            done
        fi
        echo ""
    fi

    if [ "$show_cost" -eq 1 ]; then
        echo -e "${BOLD}Token usage:${RESET}"
        local cost_json
        cost_json=$(jq -s --argjson cutoff "$cutoff_ms" '
            reduce (.[] | select(.type=="message" and .message.role=="assistant") | select((.message.timestamp // 0) >= $cutoff)) as $m
              ({input:0, output:0, cacheRead:0, cacheWrite:0, totalTokens:0, costInput:0, costOutput:0, costCacheRead:0, costCacheWrite:0, costTotal:0};
                .input += ($m.message.usage.input // 0)
                | .output += ($m.message.usage.output // 0)
                | .cacheRead += ($m.message.usage.cacheRead // 0)
                | .cacheWrite += ($m.message.usage.cacheWrite // 0)
                | .totalTokens += ($m.message.usage.totalTokens // 0)
                | .costInput += ($m.message.usage.cost.input // 0)
                | .costOutput += ($m.message.usage.cost.output // 0)
                | .costCacheRead += ($m.message.usage.cost.cacheRead // 0)
                | .costCacheWrite += ($m.message.usage.cost.cacheWrite // 0)
                | .costTotal += ($m.message.usage.cost.total // 0)
              )' "$session_file")

        local total_tokens
        local input_tokens
        local output_tokens
        local cache_read
        local cache_write
        local cost_total
        total_tokens=$(echo "$cost_json" | jq -r '.totalTokens // 0')
        input_tokens=$(echo "$cost_json" | jq -r '.input // 0')
        output_tokens=$(echo "$cost_json" | jq -r '.output // 0')
        cache_read=$(echo "$cost_json" | jq -r '.cacheRead // 0')
        cache_write=$(echo "$cost_json" | jq -r '.cacheWrite // 0')
        cost_total=$(echo "$cost_json" | jq -r '.costTotal // 0')

        echo "  Total tokens: $total_tokens"
        echo "  Input: $input_tokens | Output: $output_tokens"
        echo "  Cache read: $cache_read | Cache write: $cache_write"
        printf "  Cost total: $%.4f\n" "$cost_total"
        echo ""
    fi

    if [ "$follow" -eq 1 ]; then
        echo -e "${BOLD}Following:${RESET} $session_file"
        echo -e "${DIM}(Ctrl+C to stop)${RESET}"
        tail -f "$session_file" | while read -r line; do
            local role
            local ts_ms
            local text
            role=$(echo "$line" | jq -r 'select(.type=="message") | .message.role // empty' 2>/dev/null)
            if [ -z "$role" ]; then
                continue
            fi
            ts_ms=$(echo "$line" | jq -r '.message.timestamp // 0' 2>/dev/null)
            if [ "$ts_ms" -lt "$cutoff_ms" ]; then
                continue
            fi
            text=$(echo "$line" | jq -r '
                def text_of:
                  if (.message.content | type) == "string" then .message.content
                  else ([.message.content[]? | select(.type=="text") | .text] | join(" ")) end;
                text_of // ""' 2>/dev/null)
            if [ -z "$text" ]; then
                text="(no text)"
            fi
            echo "  [$(format_time "$ts_ms")] $role: $text"
        done
    fi
}

pi_subscribe() {
    local input="$1"
    shift

    local messages_count=1
    local follow=0
    local show_full=0
    local wait_next=1
    local show_initial=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --messages|-m)
                if [ -z "${2:-}" ]; then
                    echo "Missing value for --messages"
                    exit 1
                fi
                messages_count="$2"
                shift 2
                ;;
            --follow|-f)
                follow=1
                wait_next=0
                show_initial=1
                shift
                ;;
            --next|-n|--wait)
                follow=1
                wait_next=1
                show_initial=0
                shift
                ;;
            --last|-l)
                follow=0
                wait_next=0
                show_initial=1
                shift
                ;;
            --full)
                show_full=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ -z "$input" ]; then
        echo "Usage: dev pi-subscribe <session> [options]"
        echo ""
        echo "Subscribe to final agent messages (agent_end events)."
        echo ""
        echo "Options:"
        echo "  --messages, -m <n>  Show last n entries before following"
        echo "  --next, -n          Wait for the next entry, then exit (default)"
        echo "  --wait              Alias for --next"
        echo "  --follow, -f        Follow new entries (tail -f)"
        echo "  --last, -l          Show the last completion and exit"
        echo "  --full              Show full message text"
        exit 1
    fi

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local worktree="${parts[1]:-main}"
    local repo_dir="$PROJECTS_DIR/$repo"
    local target_dir=""
    local sub=""

    if [ -d "$repo_dir/.bare" ]; then
        target_dir="$repo_dir/$worktree"
        sub="${parts[2]:-}"
    else
        target_dir="$repo_dir"
        sub="${parts[1]:-}"
    fi

    if [ ! -d "$target_dir" ]; then
        echo "Directory not found: $target_dir"
        exit 1
    fi

    local status_file=""
    if [[ "$sub" == kw-* ]]; then
        local kw_name
        kw_name="${sub#kw-}"
        status_file=$(kw_meta_get "$repo" "$kw_name" "statusFile")
        if [ -z "$status_file" ]; then
            status_file=$(kw_status_file "$repo" "$kw_name")
        fi
    else
        local safe_path
        safe_path=$(echo "$target_dir" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
        status_file="$HOME/.pi/status/${safe_path}.jsonl"

        if [ ! -f "$status_file" ]; then
            safe_path=$(echo "$target_dir" | sed 's|/|-|g' | sed 's|^-||')
            status_file="$HOME/.pi/status/${safe_path}.jsonl"
        fi
    fi

    if [ ! -f "$status_file" ]; then
        if [ "$follow" -eq 1 ] || [ "$wait_next" -eq 1 ]; then
            local waited=0
            local timeout=10
            while [ ! -f "$status_file" ] && [ "$waited" -lt "$timeout" ]; do
                sleep 1
                waited=$((waited + 1))
            done
        fi
    fi

    if [ ! -f "$status_file" ]; then
        echo "No status file found for: $input"
        echo "Expected: $status_file"
        echo ""
        echo "Make sure the pi-subscribe extension is loaded."
        exit 1
    fi

    format_time() {
        local ts_ms="$1"
        if [ -z "$ts_ms" ] || [ "$ts_ms" = "null" ]; then
            echo "unknown"
            return
        fi
        if ! [[ "$ts_ms" =~ ^[0-9]+$ ]]; then
            echo "unknown"
            return
        fi
        local ts_s=$((ts_ms / 1000))
        date -r "$ts_s" "+%Y-%m-%d %H:%M:%S"
    }

    render_line() {
        local line="$1"
        local ts_ms
        local msg
        local status
        local stop_reason
        local error_msg
        ts_ms=$(echo "$line" | jq -r '.timestamp // 0' 2>/dev/null)
        msg=$(echo "$line" | jq -r '.message // ""' 2>/dev/null)
        status=$(echo "$line" | jq -r '.status // "done"' 2>/dev/null)
        stop_reason=$(echo "$line" | jq -r '.stopReason // empty' 2>/dev/null)
        error_msg=$(echo "$line" | jq -r '.errorMessage // empty' 2>/dev/null)

        if [ -z "$msg" ]; then
            msg="(no text)"
        fi

        if [ "$show_full" -ne 1 ]; then
            msg=$(echo "$msg" | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g')
            msg=$(echo "$msg" | cut -c1-240)
        fi

        local status_label="$status"
        if [ -n "$stop_reason" ]; then
            status_label="$status ($stop_reason)"
        fi
        if [ -n "$error_msg" ]; then
            status_label="$status error: $error_msg"
        fi

        echo "  [$(format_time "$ts_ms")] $status_label: $msg"
    }

    if [ "$show_initial" -eq 1 ]; then
        local lines
        lines=$(tail -n "$messages_count" "$status_file" 2>/dev/null || true)

        if [ -n "$lines" ]; then
            while IFS= read -r line; do
                [ -z "$line" ] && continue
                render_line "$line"
            done <<< "$lines"
        else
            echo "(no status entries)"
        fi
    fi

    if [ "$follow" -eq 1 ] || [ "$wait_next" -eq 1 ]; then
        if [ "$wait_next" -eq 1 ]; then
            local start_lines
            local current_lines
            start_lines=$(wc -l < "$status_file" | tr -d ' ')
            start_lines=${start_lines:-0}

            while true; do
                current_lines=$(wc -l < "$status_file" | tr -d ' ')
                current_lines=${current_lines:-0}
                if [ "$current_lines" -lt "$start_lines" ]; then
                    start_lines="$current_lines"
                elif [ "$current_lines" -gt "$start_lines" ]; then
                    tail -n 1 "$status_file" | while read -r line; do
                        [ -z "$line" ] && continue
                        render_line "$line"
                    done
                    break
                fi
                sleep 1
            done
            return
        fi

        echo -e "${DIM}(Ctrl+C to stop)${RESET}"
        tail -n 0 -f "$status_file" | while read -r line; do
            [ -z "$line" ] && continue
            render_line "$line"
        done
    fi
}

queue_status() {
    local input="$1"
    shift

    local show_messages=0
    local show_dead=0
    local clear_queue=0
    local clear_dead=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --messages|-m)
                show_messages=1
                shift
                ;;
            --dead-letter|-d)
                show_dead=1
                shift
                ;;
            --clear|-c)
                clear_queue=1
                shift
                ;;
            --clear-dead|--clear-dead-letter|-x)
                clear_dead=1
                shift
                ;;
            --clear-all|-a)
                clear_queue=1
                clear_dead=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ -z "$input" ]; then
        echo "Usage: dev queue-status <session> [options]"
        echo ""
        echo "Show queue status for a pi agent."
        echo ""
        echo "Options:"
        echo "  --messages, -m         Show pending queue messages"
        echo "  --dead-letter, -d      Show dead-letter entries"
        echo "  --clear, -c            Clear pending queue messages"
        echo "  --clear-dead, -x       Clear dead-letter entries"
        echo "  --clear-all, -a        Clear queue and dead-letter"
        exit 1
    fi

    IFS='/' read -ra parts <<< "$input"
    local repo="${parts[0]}"
    local worktree="${parts[1]:-main}"
    local repo_dir="$PROJECTS_DIR/$repo"
    local target_dir=""
    local sub=""

    if [ -d "$repo_dir/.bare" ]; then
        target_dir="$repo_dir/$worktree"
        sub="${parts[2]:-}"
    else
        target_dir="$repo_dir"
        sub="${parts[1]:-}"
    fi

    if [ ! -d "$target_dir" ]; then
        echo "Directory not found: $target_dir"
        exit 1
    fi

    local queue_file=""
    local dead_file=""

    if [[ "$sub" == kw-* ]]; then
        local kw_name
        kw_name="${sub#kw-}"
        queue_file=$(kw_meta_get "$repo" "$kw_name" "queueFile")
        if [ -z "$queue_file" ]; then
            queue_file=$(kw_queue_file "$repo" "$kw_name")
        fi
        dead_file="$queue_file.dead-letter"
    else
        if [ -n "$sub" ]; then
            local sub_dir="$target_dir/$sub"
            local dot_sub_dir="$target_dir/.${sub}"
            local chosen=""

            for candidate in "$sub_dir" "$dot_sub_dir"; do
                if [ -d "$candidate" ]; then
                    local safe_candidate
                    safe_candidate=$(echo "$candidate" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
                    local session_candidate="$HOME/.pi/agent/sessions/--${safe_candidate}--"
                    if [ -d "$session_candidate" ]; then
                        chosen="$candidate"
                        break
                    fi
                fi
            done

            if [ -n "$chosen" ]; then
                target_dir="$chosen"
            fi
        fi

        local safe_path
        safe_path=$(echo "$target_dir" | tr '[:upper:]' '[:lower:]' | sed 's|/|-|g' | sed 's|^-||')
        queue_file="$HOME/.pi/queues/${safe_path}.jsonl"
        dead_file="$queue_file.dead-letter"
    fi

    if [ "$clear_queue" -eq 1 ]; then
        : > "$queue_file"
        echo "Cleared queue: $queue_file"
    fi
    if [ "$clear_dead" -eq 1 ]; then
        : > "$dead_file"
        echo "Cleared dead-letter: $dead_file"
    fi

    local queue_size=0
    local dead_size=0

    if [ -f "$queue_file" ]; then
        queue_size=$(wc -c < "$queue_file" | tr -d ' ')
    fi
    if [ -f "$dead_file" ]; then
        dead_size=$(wc -c < "$dead_file" | tr -d ' ')
    fi

    echo -e "${BOLD}Queue:${RESET} $input"
    echo -e "${DIM}File: $queue_file${RESET}"
    echo -e "${DIM}Size: ${queue_size} bytes${RESET}"

    if [ "$show_messages" -eq 1 ]; then
        if [ ! -s "$queue_file" ]; then
            echo "  (no pending messages)"
        else
            echo -e "${BOLD}Pending messages:${RESET}"
            cat "$queue_file"
        fi
    fi

    echo ""
    echo -e "${DIM}Dead-letter: $dead_file${RESET}"
    echo -e "${DIM}Dead-letter size: ${dead_size} bytes${RESET}"
    if [ "$show_dead" -eq 1 ]; then
        if [ ! -s "$dead_file" ]; then
            echo "  (no dead-letter entries)"
        else
            echo -e "${BOLD}Dead-letter entries:${RESET}"
            cat "$dead_file"
        fi
    fi
}

hub_session() {
    local sub="$1"
    local session_name="hub"
    local target_dir="$PROJECTS_DIR"

    if [ -n "$sub" ]; then
        session_name="hub${SEP}${sub}"
    fi

    cd "$target_dir"
    local display_name=$(to_display_name "$session_name")
    echo -e "Directory: ${CYAN}$target_dir${RESET}"
    echo -e "Session: ${GREEN}$display_name${RESET}"

    local auto_command=()
    if [ -n "$sub" ]; then
        case "$sub" in
            pi)
                auto_command=(pi)
                ;;
            claude)
                auto_command=(claude --dangerously-skip-permissions)
                ;;
        esac
    fi

    local backend
    backend=$(session_backend "$session_name")

    if [ "$backend" = "tmux" ]; then
        tmux attach -t "$session_name"
        return
    fi

    # Create new session detached (safe for non-interactive callers)
    tmux new-session -d -s "$session_name" -c "$target_dir"
    if [ ${#auto_command[@]} -gt 0 ]; then
        local cmd_line
        cmd_line="${auto_command[*]}"
        tmux send-keys -t "$session_name" "$cmd_line" C-m
    fi
    echo -e "${GREEN}Started:${RESET} $display_name (detached)"
    echo -e "Attach with: ${CYAN}dev $display_name${RESET}"
}

# Main
case "${1:-}" in
    "")
        list_projects 0
        ;;
    hub|hub/*)
        # Extract sub-session if provided (hub/claude -> claude)
        if [[ "$1" == "hub/"* ]]; then
            sub="${1#hub/}"
            hub_session "$sub"
        else
            hub_session ""
        fi
        ;;
    "new")
        new_project "$2" "$3"
        ;;
    "wt"|"worktree")
        add_worktree "$2" "$3" "$4"
        ;;
    "kill")
        if [ -z "$2" ]; then
            echo "Usage: dev kill <session-name>"
            exit 1
        fi
        kill_session "$2"
        ;;
    "cleanup")
        cleanup_worktree "$2" "${@:3}"
        ;;
    "kill-all")
        kill_all_sessions
        ;;
    "send")
        send_keys "$2" "${@:3}"
        ;;
    "send-pi")
        send_pi "$2" "${@:3}"
        ;;
    "kw")
        kw_session "$2" "$3" "${@:4}"
        ;;
    "kw-list")
        kw_list "$2"
        ;;
    "kw-tags")
        kw_tag "$2" "${@:3}"
        ;;
    "kw-note")
        kw_note "$2" "${@:3}"
        ;;
    "pi-status")
        pi_status "${@:2}"
        ;;
    "pi-subscribe")
        pi_subscribe "${@:2}"
        ;;
    "queue-status")
        queue_status "${@:2}"
        ;;
    "requirements")
        requirements "$2" "${@:3}"
        ;;
    "review-loop")
        review_loop
        ;;
    "reboot")
        reboot_sessions "${@:2}"
        ;;
    "ls"|"list")
        if [ "${2:-}" = "--full" ] || [ "${2:-}" = "--tree" ]; then
            list_projects 1
        else
            list_projects 0
        fi
        ;;
    "help"|"-h"|"--help")
        echo "dev - Project session manager (with git worktree support)"
        echo ""
        echo "Commands:"
        echo "  dev                           List active sessions"
        echo "  dev ls [--full]              List active sessions (or full project tree)"
        echo "  dev hub                       Attach to hub session at ~/projects root"
        echo "  dev hub/<sub>                 Hub sub-session (e.g., hub/claude)"
        echo "  dev <repo>                    Attach to default worktree/session"
        echo "  dev <repo>/<worktree>         Attach to specific worktree"
        echo "  dev <repo>/<worktree>/<sub>   Attach to sub-session (prefer /pi for worktrees)"
        echo "  dev new <repo> <git-url>      Clone as worktree-based repo"
        echo "  dev wt <repo> <branch> [base] Add a worktree for branch"
        echo "  dev cleanup <repo>/<worktree> Remove worktree + branch + session (use --force if unmerged)"
        echo "  dev kw <repo> <name>          Start knowledge-worker session"
        echo "  dev kw-list [repo]            List knowledge workers"
        echo "  dev kw-tags <repo>/<name> <tags>  Set knowledge-worker tags"
        echo "  dev kw-note <repo>/<name> <note>  Set knowledge-worker note"
        echo "  dev kill <session>            Kill a session"
        echo "  dev kill-all                  Kill all sessions"
        echo "  dev send <session> <keys>     Send raw tmux keys (e.g., start pi)"
        echo "  dev send-pi <session> <msg>   Send message to pi agent's queue (Alt+Enter default)"
        echo "  dev pi-status <session> [opts] Show recent pi agent activity"
        echo "  dev pi-subscribe <session> [opts] Wait for next completion (default)"
        echo "  dev pi-subscribe <session> --last Show last completion and exit"
        echo "  dev pi-subscribe <session> -f    Follow completions (tail -f)"
        echo "  dev queue-status <session> [opts] Inspect or clear queue files"
        echo "  dev requirements <session>    View/set session requirements/notes"
        echo "  dev review-loop               Print PM review loop checklist"
        echo "  dev reboot [--dry-run]        Recreate baseline sessions after reboot"
        echo ""
        echo "Examples:"
        echo "  dev hub                       # root session at ~/projects"
        echo "  dev ls --full                 # full project tree"
        echo "  dev hub/claude                # claude session at root"
        echo "  dev new myapp git@github.com:user/myapp"
        echo "  dev myapp                     # default (main) worktree"
        echo "  dev myapp/main/pi             # pi session in main (preferred)"
        echo "  dev myapp/main/claude         # claude session in main"
        echo "  dev wt myapp feature-auth     # create feature branch worktree"
        echo "  dev myapp/feature-auth        # open that worktree"
        echo "  dev myapp/feature-auth/server # sub-session for dev server"
        echo "  dev cleanup myapp/feature-auth # remove worktree + branch + session"
        echo "  dev send replay/arb-admin-sse 'pi' Enter  # start pi in session"
        echo "  dev send-pi replay/main 'focus on tests'  # queue for pi agent"
        echo "  dev pi-subscribe replay/main              # wait for next completion"
        echo "  dev pi-subscribe replay/main --last       # show last completion"
        echo "  dev pi-subscribe replay/main -f           # follow final messages"
        echo "  dev kw replay arch --tags risk,api        # start knowledge worker"
        echo "  dev kw-list replay                        # list knowledge workers"
        echo "  dev requirements replay/main/pi          # view session requirements"
        echo "  dev review-loop                          # print PM review loop"
        echo "  dev reboot --dry-run                     # show sessions to recreate"
        echo "  dev reboot                               # recreate baseline sessions"
        echo "  dev queue-status replay/main -m -d       # inspect pending/dead messages"
        echo ""
        echo "Reminder: Read the last agent message before nudging:"
        echo "  dev pi-status <session> --messages 1"
        echo "  dev queue-status <session> -m"
        echo "  dev pi-subscribe <session> -f"
        echo "  dev requirements <session>"
        echo ""
        echo "Session naming:"
        echo "  You type: repo/worktree/sub"
        echo "  Internal session name: repo_worktree_sub"
            ;;
    *)
        attach_session "$1"
        ;;
esac
